---
title: "Wastewater Surveillance Interlab Program Analytical Code Documentation"
author: "YJ, JH"
number-sections: true
format:
  html:
    toc: true
    html-math-method: katex

---
```{r,  eval=FALSE, echo = FALSE}
# to-do's
# - set up repository ensure online viewability on interlabs github - JH
# - get comfortable authoring in quarto - both to complete online workshop https://rstudio-conf-2022.github.io/get-started-quarto/
# - insert inventory tables & flow chart images - YH
# - edit tables & images as needed - JH
# - Github section - YH to learn+teach in section
```


```{r, eval=FALSE, echo = FALSE}
#for rendering in other formats
#format:
#  docx:
#    toc: true
#    number-sections: true
#    highlight-style: github

#format:
#  html:
#    toc: true
#    html-math-method: katex
```

```{r setup}
#library(kableExtra)#for dataframe generated tables
library(networkD3) #for flowcharts
library(reticulate)#to run python in this file
```


## Introduction

Within the interlabs program, R code performs data processing, plots and statistics generation. As an aside, an ancillary collection of spreadsheets with Excel code and python code are used in sample preparation and pre-processing.

The R code ("base code") continues to evolve to serve the new requirements and exploratory analysis in the interlabs program. With the rapid advancement and frequent customizations, it was recognized the analysis process would benefit from comprehensive code tidying. As a rule-of-thumb, with each new feature development, teams should allocate a further 15-20% of time to resolve technical debts. There is currently no established tracking of technical debts besides some in-code comments and team members recollection.

The purpose of this document is:
1. To serve as documentation accompanying the code, and to be continually updated as the code evolves  
2. Set out practice standards for team to collectively continue hygienic data handling & coding following the refactoring project in 2023; serve as on-boarding training for new team members

# Environment Structure

## External File Structure

```{r}
### I. Code Documentation
#1.  Inventory existing external file dependencies and working procedures outside of main codebase, e.g. the python snippets, address books, flow of sample notes, raw, and clean data *(4 weeks / July 2023)*\
```

An inventory of file and code relationships external to the main codebase is currently is shown in Table 1 and Figure 1 below.

#### Table 1: Spreadsheets Inventory
```{r}
#Yuhan - please load into your excel table as df, then use kable package to format it 
```
: Existing Spreadsheets



## Code Internal Structure
The base code is in the Rmarkdown format with the process and optional analysis codes segmented as chunks.  Explanatory notes are primarily written in markdown prefacing each chunk of code, alongside minor comments in-line within the code chunk.  The chunks should be run from top-down to ensure that prerequisite objects are generated; part of the explanatory notes prefacing each chunk details the prerequisite requirements, and is summarized below.

#### Figure 1: Intra-base code relationships
```{r}
#Yuhan to insert flowchart code and execute the code to show figure
#*Deliverable: Inventory & flowchart of external relationships*
#2.  Inventory existing internal code dependencies and timelines (in-progress work shown in Figure 1) *(4 weeks / July 2023)*\
# **Deliverable: Inventory & flowchart of intra-basecode relationships**
```
: Intra-base code relationships

```{r}
nodes = data.frame("name" = 
                     c("Emails",                                # 0
                       "Raw data",                              # 1
                       "Clean data",                            # 2
                       "20230529_Sample_Notes.xlsm",            # 3
                       "WBE_Sample_Phasma-CA_20230511.Rmd",     # 4
                       "plots",                                 # 5
                       "dataframe",                             # 6
                       "report"))                               # 7

links = as.data.frame(matrix(c(
  0, 1, 1, # Each row represents a link. The first number
  1, 2, 1, # represents the node being conntected from. 
  2, 3, 1, # the second number represents the node connected to.
  2, 4, 1, # The third number is the value of the node
  4, 5, 1,
  4, 6, 1,
  5, 7 ,1,
  6, 7, 1),
  byrow = TRUE, ncol = 3))

names(links) = c("source", "target", "value")
sankeyNetwork(Links = links, Nodes = nodes,
              Source = "source", Target = "target",
              Value = "value", NodeID = "name",
              fontSize= 12, nodeWidth = 30)
```

    

# Operating Environment

All work must be done on OCWA-provided Windows laptops in conformance with public service technology policies.  Overall restrictions applicable to OCWA operating environment will restrict software installation - manager approvals as well as IT "white-list" may be required.  

Working file may be located in the users OCWA laptop local drive, but also available in the Wastewater surveillance team network folder, which is backed-up by IT:   
[//ocwfileeng/eng/Innov and Infra Services/WasteWater Surveillance](//ocwfileeng/eng/Innov and Infra Services/WasteWater Surveillance)

::: .call-out-note
To avoid issues, the whole path to local working project directory and names of script files should not have empty spaces.  (The configuration of the base network directory preceding "WasteWater Surveillance" cannot be changed unfortunately)
:::

## Software

|Software|Purpose|Min. Version (Extensions)|
|--------|-------|------------------------|
|Notepad ++| version control: pre-merging manual comparison|v8.5, Plugin: Compare v2|
:  Software and Versions used {#software-version}

#### R Environment

A reproducible environment for the project inside R is managed using the renv package.  renv() package is used to manage project-local R dependency, with capability to also capture Python dependency (where the latter is run off RStudio using *reticulate*).  Detailed initial set-up [steps](#renv-setup) should be executed by authorized lead only.  All other users can make use of the *renv.lock* file and project library *renv/library* to align with the working R and package versions.  Different project and branches may use different versions of packages without affecting each other.    

### Package Dependencies
Based on line-by-line run of the ![base code ](https://github.com/InterlabsOCWA/Base_code/commit/1a4da2e5cbb78f3b97cf4cabb2dd783d574a163e), otherwise named as "WBE_Sample_Phasma-CA_20230607 - facet_fractionplusHK.Rmd", the necessary packages were determined to be (flag jh - maybe take from renv.lock/github main):
(ggplot2)
(tidyverse)
(fs)
(janitor)
(readxl)
(ggh4x)
(RColorBrewer)
(scales)
(writexl)
(devEMF)
(DescTools)
(ggpubr)
(officer)

The following steps are referenced from ![](https://sites.google.com/nyu.edu/nyu-hpc/hpc-systems/greene/software/r-packages-with-renv).  

* N.B. it is highly recommended for any package update as well as the initial set-up to be done collectively with the team, as it may force update of certain packages if the versions logged in the controlled lock file are no longer available from the download source (https://stackoverflow.com/questions/60779096/error-installing-packages-using-renvrestore) *

1) Check your version of R matches the below [flag to update periodically], using the GUI's or by inputting:
```{r}
#| echo: fenced
version
# not as necessary, but the IDE version can be checked using RStudio.Version()
```
2) Make sure you have the renv installed to allow usage of renv commands below.  Version 1.0.0 recommended (this version is also logged in the lockfile)  

3) As part of cloning the project from version controlled branch you are working on, the *renv.lock* (as well as the renv/library, .Rprofile, renv/settings.json, and renv/activate.R files) should be found in your local repository location.   Opening the cloned project at the new location, by executing the below, renv will install/compile what is needed on the system, as long as the same version of R exists between systems:
```{r, eval=FALSE}
## Reproduce environment
renv::restore()
renv::init()
```

4) If package versions in project lockfile do not match the your local library, you can follow the console instruction to generate a list of packages out of sync:  
```{r, eval=FALSE}
renv::status() 
```

If your work results in changing versions of or adding packages, please refer to [steps](#renv-setup) steps 2 and 3 as well as consult the team in a timely manner.    


::: {#renv-setup .callout-note collapse="true"}
## Set up / Package library updates

The general workflow for the technical lead to initially set up with renv is:  

1. Call renv::init() to initialize a new project-local environment with a private R library.  The console should report back it has linked packages into the project library and written the renv.lock lockfile.  Three new files and directories are created:  

- i. renv/library containing all packages used by the project.  Each project refers to its own isolated library rather than using a common library  
- ii. the lockfile *renv.lock* recording metadata about every package to enable re-installation on other machines  
- iii. the project R profile *.Rprofile* which auto-runs when the project is started in R as a configuration file.  

2. As the project progress, new R packages may be installed, removed or updated.  After validated package changes, call renv::snapshot() to save the state of the project library to the lockfile.  

Option - call renv::restore() to revert to the previous state as encoded in the lockfile if the package change introduced some new problems*

3. A new commit should be made on github so that the team can update their respective local project environment.   These three components must be committed to version control:  
- i) renv.lock 
- ii) .Rprofile
- iii) renv/settings.json 
- iv) renv/activate.R    
A git-ignore file within the renv subdirectory instructs all other non-necessary files **not** to be saved to version control  
:::




For troubleshooting requiring package version check, besides cross-checking renv.lock files, refer to the package window in the corner of RStudio. 




=====  
When renv’s Python integration is active, a couple extra features will activate:  
- renv will instruct reticulate to load your project-local version of Python by default, avoiding some of the challenges with finding and selecting an appropriate version of Python on the system.  
- Calling reticulate::py_install() will install packages into the project’s Python environment by default.  
- When renv::snapshot() is called, your project’s Python library will also be captured into requirements.txt (for virtual environments) / environment.yml (for Conda environments).  
- Similarly, renv::restore() will also attempt to restore your Python environment, as encoded in requirements.txt / environment.yml from a previous snapshot.  

#### Python
- To check your version of python, use command line or in python:
```{python}
import sys
print(sys.version)
```


## Version Control
```{r}
#Yuhan's section
#### II. Training/Establishing Guidelines

#1.  Acquire training on and establish version control on Github *(2 weeks/July 2023)* *Deliverable: Training/Guidance document section, specifically method for & train team as soon as possible on version control/change management**\

### III. Preparatory Version Control & Unit Tests

#1.  Establish version control on Github. All team members to abide by training guidelines when introducing changes to main code base *(2 weeks/July 2023)*\
#    **Deliverable: Version control workflow graphic (to incl. in Training/Guidance document)**\
```

### Training/Establishing Guidelines
#### Installation and setup

1. Install Git from website: <https://gitforwindows.org/>

2. Running on terminal
    - Go to the Start menu
    - In the Search or Run line type ”cmd”and press enter
    - Check git version: `git --version`
    - Update git version if have git but not the latest version:`git update-git-for-windows`
    
    ![git](src/versionUpdate.gif).
    
3. Introduce yourself to Git
    - Type the following in cmd:
    `git config --global user.email "you@youremail.com"` 
    `git config --global user.name "Your Name"`
    - See result: `git config --global --list`
    
::: {.callout-note}
Note: This **must** be the email associated with your GitHub account.
:::

#### Connect to Git, GitHub and RStudio

4. Setup a new remote repository in GitHub
  ![repo](src/SetRepo.gif).
  
5. Connect Rstudio to GitHub and clone the repo
  ![connect](src/RStudioConnectGitHub.gif).
  
6. Detect Git from RStudio
    - Type `where git` in cmd to get the git executable path
    - From RStudio, go to *Tools > Global Options > Git/SVN* and make sure that the box *Git executable* points to your Git executable.
  ![detect](src/detect.png).

#### Git Fundamentals
7. Make changes and commit 
    - click on the **Git** tab in RStudio. You’ll notice that there’s only one file listed, since RStudio only lists files that have changed in its git interface.
    - Click on the **Staged** check box to stage your change. Now click on **Diff**(next to **Commit**) to display a summary of what’s changed. Lines that have been added are green. Lines that have been removed are red.
    - Add a commit message and click on **Commit**. Every time make a commit, must also write a short **commit message**.
    - In the **Git** tab of RStudio, click on **Diff** and then **History**. You’ll see that you can look through every commit you’ve ever made. This can be extremely useful for finding bugs or looking back to how your model looked a few months ago.
    
8. Push & Pull
    - To start working on a project,**Pull** any new changes to update local copy.
    - When you are finished and committed, to **Push** these changes to the remote repository (e.g., GitHub). Should see below image.

9. Branch
    
    **Branching** is the way to work on different versions of a repository at one time. By default your repository has one branch named`master`which is considered to be the definitive branch.
    
    When you create a branch off the `master` branch, you’re making a copy, or snapshot, of `master` as it was at that point in time. This is particularly useful when you are working on a collaborative project. For example, if someone else made changes to the `master` branch while you were working on your branch, you could pull in those updates.
    - Create a new branch on GitHub/RStudio/shell
    
    9.1. Pull Request and Merge Chances
        - You will notice that at the top of all you files there is a new section that says: **Your recently pushed branches:**. The changes you made to your script have been pushed to your online copy of the project and are now in the branch `NewPlot`. In order to merge them into your `master` branch we need to create a pull request. Click on the button that says *Compare and pull request*.
        - In the **Open a pull request** page click on **Create pull request**.
        - GitHub has now compared the two versions of your project that are in the two branches, `master` and `Newplot`and it is telling us that there are no conflicts between the two versions.
        - Now it’s time to bring your changes together – merging your `Newplot` branch into the `master` branch. Click the green **Merge pull request** button to merge the changes into master. Click **Confirm merge**. Go ahead and delete the branch, since its changes have been incorporated, with the **Delete branch** button in the purple box.

![Cross-checking in Notepad++ prior merge](img/premergeDiffNotepad.png)

## Linting / Style Guide
*General*
The ![tidyverse style](https://style.tidyverse.org/) will be the default style, and aligns with the lintr package used below.  It is recommended for all users to review the guide.  Some general format rules include:  
- camelCase recommended (note tidyverse style guide prefers snake case but both are acceptable)
- tab indentation by two spaces
*Linting - continuous integration*
In RStudio IDE:  
- some linting is included, however it is for errors only
- selecting code and hitting Ctrl + I will re-indent code for you
  
*lintr*:  
lintr package will be set up with the main code to provide diagnostic linting (i.e. as opposed to auto-correction using stylr package), recommending but not enforcing stylistic changes.  It will activate with github upload workflows following this set up command, which also creates a **.github/workflows** folder with **lint.yaml**  
  
```{r}
#| eval: FALSE
usethis::use_github_action("lint")
# for context, check in console - vignette("continuous-integration")

```

Once lintr is installed, it can be accessed in RStudio.  In order to see the diagnostic results, first enable the "Markers" pane by  > “Tools” > “Global Options…” > go to “Code” on the left-hand-side > “Diagnostics” tab > check “Show diagnostics for R”.  The Markers pane will then be available tabbed next to Console/Terminal/Background Jobs to display lint results.  

To run lintr, open Tools > Addins. From the pop-up window, select lintr from the addin's list and execute on the open code file.  
![](img/lintrRStudio.png)

*N.B. You can bind this linting process to a keyboard shortcut in RStudio in the addin's window, with Shift+Alt+L recommended *

The user may then use the lintr result in the Markers pane as a guide to modify code format.  Automated linting (e.g. styler package) is not recommended at this point.  More options for linting and details are available for reference at https://blog.r-hub.io/2022/03/21/code-style/ 
===================================

## Refactoring 
- recommend every x period
- workflow

## unit testing approaches & practices 
*At the minimum, we should aim to write tests for the "happy path" of our application.

What is a "happy path" test? "Happy path" tests are very useful, because they catch the most critical bugs, but are definitely not sufficient for building reliable and robust applications.* https://effectivecio.com/2009/11/02/the-happy-path/

The happy path is the path through a system where everything works, the data is correct, the system stays up, and the users are well-behaved.  We tend to test the happy path first because we understand how the system should function and want to ensure that the basic features should work.  We need to move off the happy path and wander in the weeds.  What if the quantity exceeds stock on hand? What if the user enters too few digits from their credit card? Or too many? Or adds a space, or a dash? What if the zip code doesn’t match the state? What if? What if? What if?

It doesn’t take long to test the happy path.  It takes forever to test everything off the happy path. You need to spend a lot of time wandering away from the happy path, and maybe there is a reverse rule for testing: 20% of your time on the happy path; 80% of your time off of it.

![ What are Unit Testing, Integration Testing and Functional Testing?](http://codeutopia.net/blog/2015/04/11/what-are-unit-testing-integration-testing-and-functional-testing/)

Automated testing is the practice of writing code to programmatically test the actual code we want to write.

It offers several benefits over manual testing:

it saves testing time (by not having to perform manual tests over and over)
it saves debugging time (by catching bugs earlier)
it makes it easier to program (because we don't need to keep the entire application in our heads, just the part that we're working on... if we break something, our tests will let us know)
it makes it easier to come back to a program after some time (programmers forget things, but tests do not)
it makes it easier to work together (we wrote some widget and know how it works, but our team-mates probably don't; our tests will catch bugs introduced by others on our team, and vice versa)
it acts as documentation (readings tests is a great way to learn about how code is meant to be used)
it improves the quality of our code (writing code that is easy to test often requires us to change how our code is structured -- for the better)
##  Issues-tracking method


7.  Document the procedures for above practices and create training presentations for the team *(3 weeks)*\
    **Deliverable: Training/Guidance document**\
    **Deliverable: Training session**

## Unit Testing Framework
2.  Set up formal testing, enabling validation of no-loss-of-function and establishing built-in "bases" during refactoring. *(August 2023)* **Deliverable: Test framework & test-suite code**

Cursory review in June 2023 found that base code functions (more suitable for testing) are few and generally used to generate plots (unsuitable for testing). Testing may be adapted to instead inspect dataframe size & output value spot-check.

-------------------------------

1.  Packages/Libraries organization *(3 weeks / July 2023)*:
    1.  create reference document of package purpose/usage in the program (including any removed but potentially useful)
    2.  remove any currently unused packages, narrowing list/call to just the necessary ones
    3.  create packrat compilation or Docker of used packages to preserve running versions\
        **Metric: Number of superfluous packages/libraries, number TBD to 0**\
        **Deliverable: One packrat / docker with all in-use packages including versions**
2.  Linting for consistent style *(1 week; August 2023)*\
    **Deliverable: Commit \[track number\]**\
3.  Refactoring cycle, which will be repeated for each issue/potential improvment. As adapted from Fowler: 0.1 Select issue/potential improvement to work on. Create branch on version control 0.2 Introduce comments/pseudo-code for changes. Obtain consensus with *reviewer*  
**Deliverable: Branch & Commit \[track number\]**
    1.  Create getters and setters for the field\
    2.  Locate all references: replace access with calls to the getter, and changes to the field with calls to the setter\
    3.  Compile and test after changing each reference\
    4.  Declare the field as private\
    5.  Compile and test. Switch to light mode for coder & reviewer\
    6.  *Reviewer* checks pull request, code and merge. Light mode for all users\
        **Deliverable: Commit \[track number\]**
4.  Documentation updates  
**Deliverable: Code & Guidance Documentation Updates, Inventory of updated intra/external code relationships **


### Table 3 - Milestone Deliverables & Tentative Schedule
| Deliverable                                                     | Timeline [In Progress/Completed] | Resp./Review |
| --------------------------------------------------------------- | -------------------------------- | ------- |
| Code Documentation                                              |                                  |         |
| 1.Inventory & flowchart of external relationships               | Summer 2023 / July 2023          |         |
| 2.Inventory & flowchart of intra-basecode relationships         | Summer 2023 / July 2023          |         |
| 3.Packages/Libraries Listing                                    | Summer 2023 / July 2023          |         |
| 4.Code Documentation - existing code comments archival          | Summer 2023 / July 2023          |         |
| 5.Kaban battle board (initial version)                          | Summer 2023 / July 2023          |         |
| Training/Guidelines                                             |                                  |         |
| 6a.Guidance Documentation - Version Control & Issues resolution | Summer 2023 / July 2023          |         |
| 6b.Guidance Documentation - Refactoring & Unit Testing          | Summer 2023 / August 2023        |         |
| 6c.Guidance Documentation - Linting, Selected Style             | Summer 2023 / July 2023          |         |
| Preparatory Staging                                             |                                  |         |
| 7.Version control established, team training session            | August 2023                      |         |
| 8.Testing framework                                             | August / September 2023          |         |
| Refactoring                                                     |                                  |         |
| 9.Refactoring cycles                                            | Autumn 2023 / November 2023?     |         |
| 10a.Code & Guidance Documentation Updates                       | Autumn 2023 / November 2023?     |         |
| 10b.Inventory of updated intra/external relationships, packages | Ongoing / December 2023          |         |
| 11.Training sessions, monthly                                   | Ongoing                          |         |
| 12.Project Completion Memo, performance metric                  | January 2023                     |         |
|                                                                 |                                  |         |



# References

*WWS Working Platforms*\
https://github.com/InterlabsOCWA\
https://www.goodday.work/p/GKN7K9

*Inventory/Code Profiling* https://bookdown.org/csgillespie/efficientR/performance.html#performance-profvis\
https://github.com/lewinfox/foodwebr https://www.researchgate.net/publication/305738639_A\_Proposal_of_Refactoring_Method_for_Existing_Program_Using_Code_Clone_Detection_and_Impact_Analysis_Method
https://rstudio.github.io/packrat/walkthrough.html  

*Unit Testing*\
https://r-pkgs.org/testing-design.html

https://webcache.googleusercontent.com/search?q=cache:q9QbZVfMwtQJ:https://www.r-bloggers.com/2019/11/automated-testing-with-testthat-in-practice/&cd=14&hl=en&ct=clnk&gl=ca

*Refactoring*\
Lemaire, 2020. *Refactoring at Scale*\
https://learning.oreilly.com/library/view/refactoring-workbook/0321109295/

*Version Control* (add existing RStudio project to Github): https://happygitwithr.com/index.html

https://hansenjohnson.org/post/sync-github-repository-with-existing-r-project/

# Appendix/Reference Extracts
## Dark Mode/Light Mode Technique

(extract from Lemaire, 2020. *Refactoring at Scale*)\
Dark Mode / Light Mode : We can compare pre-refactor and post-refactor behavior by employing what we've coined at Slack as the light/dark technique\
Dark mode : Both implementations are called\
The results are compared\
The results from the old implementation are returned

Light mode :\
Both implementations are called\
The results are compared\
The results from the new implementation are returned

How To ?\
Once the abstraction has been properly put in place\
Start enabling dark mode\
Monitor any differences being logged between the two result sets\
Track down and fix any potential bugs in the new implementation causing those discrepancies\
Repeat this process until you've properly handled all discrepancies, Enabling dark mode to broader groups of users

Once all users have been opted in to dark mode\
Continue logging any differences in the result sets\
Continue to opt broader groups of users into light mode, until everyone is successfully processing results from the new implementation.

Disable execution of both code paths\
Remove the old logic altogether : only the new implementation should remain

## Typical Code Issues & Correspondent Refactoring

### Refactoring methods

a.  Extraction: breaking code into chunks or utilizing existing chunks for isolation into separate functions and replaced with a call to the functions. Change patterns into abstraction. Similarly for variables
b.  Inline refactoring: finding functions calls and replacing them with the function content (opposite of extraction)
c.  Simplifying methods logic: consolidate conditional fragments and using polymorphism instead of conditionals
d.  Simplifying method calls: examining parameters involved and adding/replacing as needed

## Handling Commented-out code
\## stuff to incorp. COMMENTED-OUT CODE In the case of commented-out code, it's pretty obvious that the code is unused. I always recommend that developers who are tempted to comment-out code instead simply delete it if the code is tracked using version control. If you need it again someday, you can easily recover it by going back through your commit history.

new function to help mitigate code degradation. Let's say we write up a simple helper to encapsulate all the logic for validating a user object; we'll call it validateUser

A NOTE ABOUT COUNTING LINES OF COMMENTS By and large, ignoring comments is good practice when counting lines of code. Docblocks and inlined TODOs do not affect the behavior of our programs, so including them in our size calculations would not help us better characterize a program's complexity. In practice, however, I've noticed that you can easily pinpoint some rather perplexing sections of code by counting the number of inline comments at the function level. In general, developers tend to leave inline code comments when the surrounding logic is difficult to follow. Whether that's because the code is dealing with a complicated piece of business logic or it has just become gradually more convoluted over time, we tend to leave some pointers to others who come after us when modifying exceptionally tricky code. Therefore, we can use the quantity of inline comments within a single function, whether short or long, as a possible warning sign.

When we're working to improve an existing implementation, whatever the extent of our endeavor, we want to be sure that we're correctly retaining its behavior. We can safely assert that our new solution continues to work identically to the old by relying on the original implementation's test suite. Because we are relying on the test coverage to warn us about potential regressions, we need to verify two things before beginning our refactoring effort: first, confirm that the original implementation has test coverage and, second, determine whether that test coverage is adequate.\
refactoring requires us to be able to ensure that behavior remains identical at every iteration. We can increase our confidence that nothing has changed by writing a suite of tests (unit, integration, end to end), and we should not seriously consider moving forward with any refactoring effort until we've established sufficient test coverage.

## Unit testing notes

-   Set a canary test (it checks if the test framework works)

-   Add few (automated) tests. Start with code candidate to change first. If code wasn't designed to be testable, don't change it yet. Make your best to test it as is. This is very important.


### Misc. heap of code
Find main package list + versions:
```{r}
#| echo: fenced
print(head
      (tibble::tibble(
        Package = names(installed.packages()[,3]),
        Version = unname(installed.packages()[,3])
      ), n=600 #where n = an appropriately large value to capture all your packages
      )
)
```
